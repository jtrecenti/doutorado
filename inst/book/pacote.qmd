---
bibliography: references.bib
---

# Pacotes {#sec-pacote}

<!-- Este apêndice foi construído para mostrar a estrutura do pacote e suas funcionalidades, mas também um pouco da história. O pacote `{captcha}` é fruto de um trabalho da comunidade e o trabalho de modelagem de Captchas usando técnicas de *deep learning*, que começou alguns anos antes do início da tese de doutorado. -->

Este apêndice foi construído para mostrar a estrutura dos pacotes `{captchaDownload}` e `{captchaOracle}`, utilizados como auxiliares para implementação do WAWL, orquestradas pelo pacote `{captcha}`. Apresenta-se também um breve histórico sobre a construção das soluções desenvolvidas, descrevendo alternativas e projetos que foram aposentados.

## Histórico {#sec-historico}

O trabalho de resolução de Captchas pelo autor da tese surgiu no ano de 2016. Como foi comentado na introdução da tese, é muito comum se deparar com desafios de Captchas ao raspar dados do judiciário, já que estes dados não são abertos.

O primeiro Captcha a ser investigado foi o do sistema e-SAJ. O desafio era utilizado no site do TJSP que, depois de alguns anos, passou a utilizar o sistema reCaptcha. O Captcha do e-SAJ faz parte da tese, mas tem como fonte de dados o TJBA, que continua utilizando o desafio até o momento que os sites foram investigados pela última vez, em setembro de 2022.

A primeira abordagem para resolver o Captcha do e-SAJ foi utilizando heurísticas para separar as letras, em 2016. Infelizmente o pacote original, chamado `{captchasaj}`, foi removido da *internet*, mas um código legado construído para o TJRS está disponível [neste link](https://github.com/decryptr/captchaTJRS/blob/master/R/tools.R). Nessa abordagem, as letras primeiro são segmentadas, alimentando um modelo de florestas aleatórias que considera os pixels da imagem como variáveis preditoras e a letra como resposta. Esses trabalhos tiveram contribuições importantes de Fernando Corrêa e Athos Damiani, ambos do IME-USP.

A segunda abordagem para resolver os Captchas foi utilizando o áudio, também em 2016. O código para resolver o Captcha da RFB utilizando áudio está disponível [neste link](https://github.com/decryptr/captchaReceitaAudio). A ideia de resolução era parecida, passando pelo procedimento de segmentação e depois de modelagem, mas tinha um passo intermediário de processamento envolvendo engenharia de *features* [@kuhn2019]. O trabalho teve contribuições importantes de Athos Damiani.

Com o advento da ferramenta TensorFlow para o R [@tensorflow], os modelos para resolver Captchas passaram a utilizar modelos de redes neurais. No início, por falta de conhecimento da área, a arquitetura das redes era demasiadamente complexa. Depois que os primeiros modelos começaram a funcionar, notou-se que as etapas de pré-processamento com segmentação e algumas camadas das redes eram desnecessárias para ajustar os modelos. Essa parte teve grande contribuição de Daniel Falbel, também do IME-USP, que foi a pessoa que introduziu o TensorFlow e a área de *deep learning* para a comunidade brasileira de R.

Depois de resolver com sucesso alguns Captchas, notou-se que seria possível criar um ambiente completo de modelagem de Captchas. Isso deu origem ao pacote `{decryptr}` [@decryptr], que foi construído em 2017. O trabalho teve grandes contribuições de Caio Lente, do curso de Ciência da Computação do IME-USP e outros colegas de faculdade.

Com o passar do tempo, o pacote `{decryptr}` ficou cada vez mais estável, funcionando como dependência de várias ferramentas utilizadas em trabalhos de jurimetria. O pacote também ganhou um site: <https://decryptr.xyz> e uma API com acesso gratuito, precisando apenas de uma chave de acesso. A ferramenta ficou bastante popular, com [178 estrelas no GitHub](https://github.com/decryptr/decryptr) no mês de dezembro de 2022. Essas ferramentas envolveram contribuições principalmente de Caio Lente e Daniel Falbel.

A construção do pacote `{captcha}` separada do `{decryptr}` se deu por dois motivos. Primeiro, o pacote `{decryptr}`, por ser o primeiro a tratar do assunto, possui muitos códigos legados e dificuldades de instalação por conta da dependência do python, necessário para o funcionamento do TensorFlow, que é chamado através do pacote `{reticulate}` [@reticulate]. Além disso, a implementação das técnicas do oráculo envolviam modificações na função de perda, que são mais difíceis de implementar no ambiente do `{tensorflow}`, justamente por conta da necessidade de conhecer o código python que roda por trás dos códigos em R.

Com o advento do pacote `{torch}` [@torch], no entanto, tudo foi facilitado. O pacote não possui dependências com o python, além de ser bastante transparente e flexível na construção da arquitetura do modelo, funções de perda e otimização. O pacote, também construído por Daniel Falbel, é um grande avanço científico e facilitou muito a construção dos códigos desta tese.

O pacote `{captcha}`, apesar de ter sido construído do zero, foi desenvolvido durante *lives* realizadas na plataforma *Twitch*. A construção em *lives* foi interessante porque era possível obter *feedback* e ideias da comunidade durante a construção da ferramenta, o que acelerou o desenvolvimento e auxiliou na arquitetura do pacote.

Com o desenvolvimento da tese, notou-se a necessidade de construir alguns pacotes adicionais. Os pacotes `{captchaDownload}` e `{captchaOracle}` foram desenvolvidos para facilitar a obtenção dos resultados da tese, enquanto o pacote `{captcha}` pode ser utilizado por qualquer pessoa interessada em visualizar, anotar e resolver Captchas. As próximas subseções do apêndice descrevem os pacotes `{captchaDownload}` e `{captchaOracle}`.

## Pacote captchaDownload {#sec-pacote-download}

O pacote `{captchaDownload}` foi construído para armazenar os códigos de baixar dados de Captchas de forma consistente. O pacote também inclui funções para trabalhar com oráculos.

O pacote não foi criado para ser usado pelo público geral. O intuito de criar o pacote foi o de organizar as funções utilizadas para realizar as simulações e obter os resultados empíricos da tese. Apesar disso, o código está disponível publicamente para quem tiver interesse em usar como referência para construir funções que acessam o oráculo.

As funções do pacote `{captchaDownload}` são organizadas em dois tipos principais. As funções de *acesso*, identificadas pelo termo `_access`, fazem o *download* da imagem do Captcha e retornam todas as informações necessárias para fazer a verificação do oráculo, como, por exemplo, *cookies* e dados da sessão do usuário. Já as funções de *teste*, identificadas pelo termo `_test`, servem para verificar se um rótulo fornecido para o Captcha está correto ou não.

As funções ficam mais claras através de um exemplo. No caso do TRF5, por exemplo, o acesso é feito pela página do [sistema PJe](https://pje.trf5.jus.br/pjeconsulta/ConsultaPublica/listView.seam). A função `captcha_access_trf5()` recebe o parâmetro `path=`, que é a pasta para salvar a imagem, retornando uma lista com o caminho da imagem que foi salva e de componentes da sessão do usuário.

```{r}
#| echo: true
#| eval: false
acesso <- captchaDownload:::captcha_access_trf5("assets/img")
acesso
```

    $f_captcha
    assets/img/trf5ac031dafbd.jpeg
    
    $j_id
    [1] "j_id1"
    
    $u
    [1] "https://pje.trf5.jus.br/pjeconsulta/ConsultaPublica/listView.seam"



```{r}
acesso <- list(
  f_captcha = "assets/img/trf5ac031dafbd.jpeg", 
  j_id = "j_id1", 
  u = "https://pje.trf5.jus.br/pjeconsulta/ConsultaPublica/listView.seam"
)
```

Em seguida, obtém-se o rótulo do modelo. Isso pode ser feito manualmente ou através de um modelo.

```{r}
#| label: fig-exemplo-acesso-trf5
#| fig-cap: "Exemplo de Captcha baixado diretamente do TRF5."
#| out-width: 20%
#| echo: true
library(captcha)
captcha <- read_captcha(acesso$f_captcha)
plot(captcha)
modelo_trf5 <- captcha_load_model("trf5")
(lab <- decrypt(acesso$f_captcha, modelo_trf5))
```

Agora, aplica-se a função `captcha_test_trf5()` para verificar se o rótulo está correto ou incorreto. A verificação é feita de forma automática, diretamente da *internet*, através do oráculo. A função recebe dois parâmetros: `obj=` com as informações obtidas da função de acesso; e `label=`, o rótulo obtido. A função retorna `TRUE` se o rótulo está correto e `FALSE` caso contrário.

```{r}
#| echo: true
#| eval: false
(acertou <- captchaDownload:::captcha_test_trf5(acesso, lab))
```

    [1] TRUE

Cada Captcha possui uma função de acesso e uma função de teste. Na prática, se uma pessoa desejar resolver um novo Captcha usando a técnica do oráculo, são essas funções que ela precisaria desenvolver. Todas as outras operações podem ser generalizadas para diferentes casos de uso e estão implementadas nos pacotes `{captchaDownload}` e `{captchaOracle}`. Vale notar que a construção dessas funções geralmente é necessária para a construção de *web scrapers*, ou seja, elas não criam dificuldades adicionais para pessoas interessadas em resolver Captchas para acessar dados da *internet*. 

A função principal do pacote `{captchaDownload}` é a `captcha_oracle()`. A função é responsável por realizar a anotação parcial automática dos Captchas utilizando um modelo inicial e o oráculo. A função possui os seguintes parâmetros:

- `path=`: caminho em que os arquivos serão salvos.
- `model=`: modelo para predizer o rótulo de uma imagem.
- `max_ntry=`: quantidade máxima de chutes até desistir.
- `manual=`: caso o máximo de tentativas seja alcançado, abrir o *prompt* para anotar manualmente? Por padrão, sim.
- `captcha_access=`: função que baixa um Captcha e retorna dados da sessão para validar o Captcha, como mostrada anteriormente.
- `captcha_test=`: função que testa se um Captcha está correto a partir de um rótulo específico, como mostrado anteriormente.

A função amarra todos os conceitos necessários para criar bases de dados de forma automática. Primeiro, considera o caminho para salvar os dados. Em seguida, considera o modelo e formas de lidar com o oráculo. Por último, recebe as funções de acesso e de teste do Captcha. A função escreve um arquivo de *log* com os resultados dos testes. O arquivo contém `max_ntry` linhas, podendo ter uma linha adicional se `manual=TRUE`, já que, se o modelo errar todos os chutes, a anotação manual deve ser adicionada.

No exemplo do TRF5, a chamada da função `captcha_oracle()` com um chute ficaria da seguinte forma:

```{r}
#| eval: false
#| echo: true
modelo_trf5 <- captcha_load_model("trf5")

captchaDownload::captcha_oracle(
  path = "assets/img/",
  model = modelo_trf5, 
  max_ntry = 1,
  manual = TRUE, 
  captcha_access = captchaDownload:::captcha_access_trf5,
  captcha_test = captchaDownload:::captcha_test_trf5
)

```

    ✔ Acertou!!!

No teste do exemplo, a função acertou, salvando o seguinte arquivo de *log*[^espacos-adicionados-1].

    ntry, label , type, result
    1,    569328, auto, TRUE

[^espacos-adicionados-1]: Espaços foram adicionados manualmente para facilitar a visualização.

Abaixo, foi colocado um modelo ruim para o TRT, para forçar o modelo a errar todos os chutes. O resultado é o *log* abaixo

```{r}
#| eval: false
#| echo: true
modelo <- captcha_load_model("assets/modelo_ruim.pt")

captchaDownload::captcha_oracle(
  path = "assets/img/",
  model = modelo, 
  max_ntry = 10,
  manual = TRUE, 
  captcha_access = captchaDownload:::captcha_access_trt,
  captcha_test = captchaDownload:::captcha_test_trt
)
```

    ℹ Temos 10 candidatos...
    ℹ Errou! O chute foi: v2su7w
    ℹ Errou! O chute foi: t2su7w
    ℹ Errou! O chute foi: v2su7y
    ℹ Errou! O chute foi: t2su7y
    ℹ Errou! O chute foi: y2su7w
    ℹ Errou! O chute foi: v2su7h
    ℹ Errou! O chute foi: t2su7h
    ℹ Errou! O chute foi: y2su7y
    ℹ Errou! O chute foi: v2wu7w
    Label: v2xu7w

No novo exemplo, a função errou todos os dez chutes, salvando o seguinte arquivo de *log*[^espacos-adicionados-2]. O último valor é um rótulo inserido manualmente.

    ntry,  label,   type, result
       1, v2su7w,   auto,  FALSE
       2, t2su7w,   auto,  FALSE
       3, v2su7y,   auto,  FALSE
       4, t2su7y,   auto,  FALSE
       5, y2su7w,   auto,  FALSE
       6, v2su7h,   auto,  FALSE
       7, t2su7h,   auto,  FALSE
       8, y2su7y,   auto,  FALSE
       9, v2wu7w,   auto,  FALSE
      10, 92su7w,   auto,  FALSE
      NA, v2xu7w, manual,   TRUE

[^espacos-adicionados-2]: Espaços foram adicionados para facilitar a visualização.

Se o parâmetro `manual=FALSE` e o modelo não consegue acertar o rótulo, a função também adiciona a mensagem:

    ✖ Errado depois de todas as tentativas...

Em alguns casos, é possível que a função realize menos do que `max_ntry` chutes. Isso acontece quando a probabilidade do melhor rótulo depois do chute errado é muito pequena, segundo o modelo. Isso é feito pela função `captcha_candidates()`, que considera como padrão o corte de `0.01` de probabilidade. Ou seja, na prática, a função testa no máximo os `max_ntry` rótulos com probabilidades maiores que `0.01` segundo o modelo.

Em resumo, o pacote `{captchaDownload}` contém toda a parte de *web scraping* utilizada no desenvolvimento da tese. Adicionalmente, o pacote contém funções para orquestrar o *download* automático de Captchas parcialmente rotulados, a partir de um modelo inicial e um oráculo. 

Os dados fornecidos pelo pacote ficam tanto na forma de imagens rotuladas quanto na forma de arquivos de *log*, disponibilizados em arquivos *CSV*. Para lidar com essa estrutura de dados, mais um pacote foi desenvolvido: o `{captchaOracle}`, definido a seguir.

## Pacote captchaOracle {#sec-pacote-oracle}

O pacote `{captchaOracle}`, assim como o `{captchaDownload}`, foi desenvolvido para a construção da tese. O pacote, portanto, não apresenta documentação extensiva e suas funções podem não estar com a sintaxe final. Futuramente, o pacote poderá funcionar como novo *backend* para o pacote `{captcha}`, aplicando o WAWL como uma alternativa no fluxo de resolução de Captchas definido na Subseção [-@sec-captcha-do-zero]. 

O pacote possui quatro funções principais: a `captcha_dataset_oracle()`, a  `net_captcha_oracle()`, a `oracle_loss()` e a `captcha_accuracy_oracle()`. Cada função desempenha um papel similar a seus pares do pacote `{captcha}`, mas conseguem lidar com a estrutura de dados fornecida pelo oráculo.

A primeira função a ser utilizada é a `captcha_dataset_oracle()`. Trata-se de uma função similar à `captcha_dataset()` do pacote `{captcha}`, mas com um parâmetro adicional, `path_logs=`, que recebe o caminho dos arquivos de *log*.

A estrutura de dados no caso do oráculo é mais complexa do que no caso canônico. Na resposta, ao invés de guardar uma matriz *one hot* para cada Captcha, é armazenada uma lista com várias matrizes *one hot*, uma para cada tentativa do Captcha. Além disso, é armazenado um vetor `z`, com zeros e uns, informando se algum rótulo está correto ou se todos os rótulos estão incorretos. A variável `z` é construída a partir dos nomes dos arquivos, que contém um `_1` caso o rótulo esteja correto e `_0` caso contrário. Por último, a imagem de entrada é armazenada da mesma forma que na função `captcha_dataset()`.

O módulo `net_captcha_oracle()` faz poucos ajustes à estrutura inicial fornecida pelo módulo `net_captcha()` do pacote `{captcha}`. A única modificação da função é que ela recebe um modelo inicial de entrada, transferindo os pesos ajustados do modelo ao novo módulo. O módulo `net_captcha_oracle()`, inclusive, poderia ser utilizado fora do contexto do WAWL, já que só utiliza os dados de *input*, que não são alterados.

A função `captcha_accuracy_oracle()` é utilizada para estimar a acurácia do modelo. Para isso, a função precisa lidar com o fato de que os dados de validação apresentam uma estrutura diferente dos dados de treino, já que estão completamente anotados. No treino, a acurácia é calculada considerando apenas os casos em que a resposta é conhecida. Na validação, a acurácia é calculada considerando-se todas as observações.

Por último, a função `oracle_loss()` é a que contém a proposta de função de perda do método WAWL. Nos casos corretos, a função de perda é obtida calculando-se uma entropia cruzada simples. Nos casos incorretos, a perda é calculada pela estratégia `1-p`, ou seja, considerando o complementar da probabilidade de observar os chutes que foram apresentados segundo o modelo.

Em resumo, o pacote `{captchaOracle}` é o que contém os principais avanços da tese do ponto de vista estatístico. Na prática, é utilizado como *backend* computacional para ajuste dos modelos que utilizam o oráculo, dentro de um fluxo de trabalho igual ao que é construído para ajuste dos modelos canônicos. 

Os códigos para realizar as simulações do modelo foram adicionados na pasta `data-raw` do pacote `{captchaOracle}`. Os códigos foram organizados da seguinte forma:

- `passo_01_*.R`. Contêm os códigos utilizados para ajustar os modelos iniciais. Os códigos são organizados de forma a permitir que vários modelos sejam rodados em paralelo, aproveitando o máximo do poder computacional da máquina utilizada para realizar os ajustes.
- `passo_02_*.R`. Contêm os códigos utilizados para construir as bases de treino e validação para o passo 03. Foi o passo mais demorado da simulação, já que envolveu acessar os sites dos tribunais pela *internet* para obtenção dos Captchas anotados automaticamente. Para realizar a simulação, foram baixados mais de 500.000 Captchas da *internet*.
- `passo_03_*.R`. Contêm os códigos utilizados para ajustar os modelos finais. Os códigos foram organizados de forma similar ao passo 01, mas utilizando as funções desenvolvidas no pacote `{captchaOracle}` para considerar os dados fornecidos pelo oráculo.

Por fim, foi adicionado também um script `report.R`, que monta as bases principais e os resumos dos modelos ajustados. As bases fornecidas pelo último *script* foram adicionadas ao repositório da tese.
